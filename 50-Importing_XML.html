
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="LibreOffice Programming (LO-P) is intended for programmers who want  to learn how to use the the LibreOffice API. This allows programs to control  and manipulate LibreOffice's text, drawing, presentation, spreadsheet, and  database applications, and a lot more (e.g. its spell checker, forms  designer, and charting tools).  ">
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-7.0.6">
    
    
      
        <title>Chapter 50. Importing XML - LibreOffice Programming</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.2c0c5eaf.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.7fa14f5b.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="css/extra.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="preference" data-md-color-primary="" data-md-color-accent="">
      
        <script>matchMedia("(prefers-color-scheme: dark)").matches&&document.body.setAttribute("data-md-color-scheme","slate")</script>
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-50-importing-xml" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="LibreOffice Programming" class="md-header__button md-logo" aria-label="LibreOffice Programming" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LibreOffice Programming
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 50. Importing XML
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/flywire/lo-p/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lo-p
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="LibreOffice Programming" class="md-nav__button md-logo" aria-label="LibreOffice Programming" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    LibreOffice Programming
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/flywire/lo-p/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lo-p
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="index.html" class="md-nav__link">
        Preface
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="01%20Part%201%20Basics.html" class="md-nav__link">
        Part 1 Basics
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="01-Concepts.html" class="md-nav__link">
        Chapter 1. LibreOffice API Concepts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="02-Starting_and_Stopping.html" class="md-nav__link">
        Chapter 2. Starting and Stopping
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="03-Examining.html" class="md-nav__link">
        Chapter 3. Examining
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="04-Listening.html" class="md-nav__link">
        Chapter 4. Listening, and Other Techniques
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="05%20Part%202%20Writer.html" class="md-nav__link">
        Part 2 Writer
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="05-Text_API_Overview.html" class="md-nav__link">
        Chapter 5. Text API Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="06-Text_Styles.html" class="md-nav__link">
        Chapter 6. Text Styles
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="07-Non-text_Content.html" class="md-nav__link">
        Chapter 7. Text Content Other than Strings
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="08-Graphic_Content.html" class="md-nav__link">
        Chapter 8. Graphic Content
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="09-Text_Search.html" class="md-nav__link">
        Chapter 9. Text Search and Replace
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="10-Linguistics.html" class="md-nav__link">
        Chapter 10. The Linguistics API
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="11%20Part%203%20Draw%20%26%20Impress.html" class="md-nav__link">
        Part 3 Draw & Impress
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="11-Draw_Impress_APIs.html" class="md-nav__link">
        Chapter 11. Draw/Impress APIs Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="12-Examining_DrawImpress.html" class="md-nav__link">
        Chapter 12. Examining a Draw/Impress Document
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="13-Basic_Shapes.html" class="md-nav__link">
        Chapter 13. Drawing Basic Shapes
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="14-Animation.html" class="md-nav__link">
        Chapter 14. Animation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="15-Complex_Shapes.html" class="md-nav__link">
        Chapter 15. Complex Shapes
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="16-Making_Slides.html" class="md-nav__link">
        Chapter 16. Making Slides
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="17-Slide_Deck_Manipulation.html" class="md-nav__link">
        Chapter 17. Slide Deck Manipulation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="18-Slide_Shows.html" class="md-nav__link">
        Chapter 18. Slide Shows
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="19%20Part%204%20Calc.html" class="md-nav__link">
        Part 4 Calc
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="19-Calc_API_Overview.html" class="md-nav__link">
        Chapter 19. Calc API Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="20-Spreadsheet_Manipulation.html" class="md-nav__link">
        Chapter 20. Spreadsheet Displaying and Creation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="21-Extracting_Data.html" class="md-nav__link">
        Chapter 21. Extracting Data
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="22-Styles.html" class="md-nav__link">
        Chapter 22. Styles
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="23-Garlic_Secrets.html" class="md-nav__link">
        Chapter 23. Garlic Secrets
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="24-Complex_Data_Manipulation.html" class="md-nav__link">
        Chapter 24. Complex Data Manipulation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="25-Monitoring_Sheets.html" class="md-nav__link">
        Chapter 25. Monitoring Sheets
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="26-Search_Replace.html" class="md-nav__link">
        Chapter 26. Search and Replace
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="27-Funcs_Analysis.html" class="md-nav__link">
        Chapter 27. Functions and Data Analysis
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="28%20Part%205%20Chart.html" class="md-nav__link">
        Part 5 Chart
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="28-Chart2_API_Overview.html" class="md-nav__link">
        Chapter 28. Chart2 API Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="29-Column_Charts.html" class="md-nav__link">
        Chapter 29. Column Charts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="30-Bar_Pie_Area_Line_Charts.html" class="md-nav__link">
        Chapter 30. Bar, Pie, Area, Line Charts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="31-XY_Scatter_Charts.html" class="md-nav__link">
        Chapter 31. XY (Scatter) Charts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="32-Bubble_Net_Stock_Charts.html" class="md-nav__link">
        Chapter 32. Bubble, Net, Stock Charts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="33-Charts_in_Others_Docs.html" class="md-nav__link">
        Chapter 33. Using Charts in Other Documents
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="34%20Part%206%20Base.html" class="md-nav__link">
        Part 6 Base
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="34-JDBC_to_Base_API.html" class="md-nav__link">
        Chapter 34. From JDBC to the Base API
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="35-Examining_Base_Docs.html" class="md-nav__link">
        Chapter 35. Examining Base Documents
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="36-RowSets_DB_Context.html" class="md-nav__link">
        Chapter 36. Using RowSets and Database Context
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="37-Driver_Manager.html" class="md-nav__link">
        Chapter 37. Using the Driver Manager
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="38-ODB_as_Zip.html" class="md-nav__link">
        Chapter 38. Treating an ODB File as a Zipped Folder
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="39%20Part%207%20Cross-application.html" class="md-nav__link">
        Part 7 Cross-application
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="39-Forms_API_Overview.html" class="md-nav__link">
        Chapter 39. Forms API Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="40-Building_a_Form.html" class="md-nav__link">
        Chapter 40. Building a Form Programmatically
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="41-Printing.html" class="md-nav__link">
        Chapter 41. Printing
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="42-Sending_E-mail.html" class="md-nav__link">
        Chapter 42. Sending E-mail
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="43-Using_the_Clipboard.html" class="md-nav__link">
        Chapter 43. Using the Clipboard
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="44-Office_as_GUI_Comp.html" class="md-nav__link">
        Chapter 44. Office as a GUI Component
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="45%20Part%208%20Extending%20LibreOffice.html" class="md-nav__link">
        Part 8 Extending LibreOffice
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="45-UNO_Components.html" class="md-nav__link">
        Chapter 45. Coding UNO Components
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="46-Addons.html" class="md-nav__link">
        Chapter 46. Add-ons
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="47-Calc_Add-ins.html" class="md-nav__link">
        Chapter 47. Calc Add-ins
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="48-Event_Macros.html" class="md-nav__link">
        Chapter 48. Event Macros
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="49-Ext_Doc_Event_Macros.html" class="md-nav__link">
        Chapter 49. Extension and Document Event Macros
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="50%20Part%209%20The%20ODF%20Format.html" class="md-nav__link">
        Part 9 The ODF Format
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Chapter 50. Importing XML
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="50-Importing_XML.html" class="md-nav__link md-nav__link--active">
        Chapter 50. Importing XML
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-filters-to-the-rescue" class="md-nav__link">
    1.  Filters to the Rescue
  </a>
  
    <nav class="md-nav" aria-label="1.  Filters to the Rescue">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-the-clubs-example" class="md-nav__link">
    1.1.  The Clubs Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-command-line-importing-and-exporting" class="md-nav__link">
    1.2.  Command Line Importing (and Exporting)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-finding-a-filter-name" class="md-nav__link">
    1.3.  Finding a Filter Name
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-using-filters-with-java" class="md-nav__link">
    2.  Using Filters with Java
  </a>
  
    <nav class="md-nav" aria-label="2.  Using Filters with Java">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-importing-xml-with-java" class="md-nav__link">
    2.1.  Importing XML with Java
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-exporting-xml-with-java" class="md-nav__link">
    2.2.  Exporting XML with Java
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-alternatives-to-xslt-filters" class="md-nav__link">
    3.  Alternatives to XSLT Filters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-data-extraction-by-dom-parsing" class="md-nav__link">
    1.  Data extraction by DOM parsing;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-node-and-attribute-data-extraction-as-labeled-strings" class="md-nav__link">
    2.  Node and attribute data extraction as labeled strings;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-jaxb-conversion-of-xml-to-java-objects" class="md-nav__link">
    3.  JAXB conversion of XML to Java objects.
  </a>
  
    <nav class="md-nav" aria-label="3.  JAXB conversion of XML to Java objects.">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-data-extraction-by-dom-parsing" class="md-nav__link">
    3.1.  Data Extraction by DOM Parsing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-node-and-attribute-data-extraction-as-labeled-strings" class="md-nav__link">
    3.2.  Node and Attribute Data Extraction as Labeled Strings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-jaxb-conversion-of-xml-to-java-objects" class="md-nav__link">
    3.3.  JAXB Conversion of XML to Java Objects
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-convert-clubsxml-to-xsd-at-freeformattercom-using-the-salami-slice" class="md-nav__link">
    1.  Convert clubs.xml to XSD at freeformatter.com using the "Salami Slice"
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-convert-companyxsd-into-java-classes-with-xjc" class="md-nav__link">
    2.  Convert company.xsd into Java classes with xjc:
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-compile-the-clubs-package" class="md-nav__link">
    3.  Compile the Clubs package:
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="51-Simple_ODF.html" class="md-nav__link">
        Chapter 51. Simple ODF
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-filters-to-the-rescue" class="md-nav__link">
    1.  Filters to the Rescue
  </a>
  
    <nav class="md-nav" aria-label="1.  Filters to the Rescue">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-the-clubs-example" class="md-nav__link">
    1.1.  The Clubs Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-command-line-importing-and-exporting" class="md-nav__link">
    1.2.  Command Line Importing (and Exporting)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-finding-a-filter-name" class="md-nav__link">
    1.3.  Finding a Filter Name
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-using-filters-with-java" class="md-nav__link">
    2.  Using Filters with Java
  </a>
  
    <nav class="md-nav" aria-label="2.  Using Filters with Java">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-importing-xml-with-java" class="md-nav__link">
    2.1.  Importing XML with Java
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-exporting-xml-with-java" class="md-nav__link">
    2.2.  Exporting XML with Java
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-alternatives-to-xslt-filters" class="md-nav__link">
    3.  Alternatives to XSLT Filters
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-data-extraction-by-dom-parsing" class="md-nav__link">
    1.  Data extraction by DOM parsing;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-node-and-attribute-data-extraction-as-labeled-strings" class="md-nav__link">
    2.  Node and attribute data extraction as labeled strings;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-jaxb-conversion-of-xml-to-java-objects" class="md-nav__link">
    3.  JAXB conversion of XML to Java objects.
  </a>
  
    <nav class="md-nav" aria-label="3.  JAXB conversion of XML to Java objects.">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-data-extraction-by-dom-parsing" class="md-nav__link">
    3.1.  Data Extraction by DOM Parsing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-node-and-attribute-data-extraction-as-labeled-strings" class="md-nav__link">
    3.2.  Node and Attribute Data Extraction as Labeled Strings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-jaxb-conversion-of-xml-to-java-objects" class="md-nav__link">
    3.3.  JAXB Conversion of XML to Java Objects
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-convert-clubsxml-to-xsd-at-freeformattercom-using-the-salami-slice" class="md-nav__link">
    1.  Convert clubs.xml to XSD at freeformatter.com using the "Salami Slice"
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-convert-companyxsd-into-java-classes-with-xjc" class="md-nav__link">
    2.  Convert company.xsd into Java classes with xjc:
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-compile-the-clubs-package" class="md-nav__link">
    3.  Compile the Clubs package:
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/flywire/lo-p/edit/master/docs/50-Importing_XML.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="chapter-50-importing-xml">Chapter 50. Importing XML</h1>
<div class="admonition note">
<p class="admonition-title">Topics</p>
<p>XSLT Filters; 
Using Filters with Java; 
Alternatives to XSLT 
Filters: DOM Parsing, 
Node and Attribute Data 
Extraction, JAXB 
Conversion </p>
<p>Example folders: "Filter 
Tests" and "Utils" </p>
</div>
<p>This chapter is mostly about importing XML data into 
Office. I start by looking at XSLT import (and export) 
filters, which give the best results but require the 
programmer to know a great deal about XML and the 
ODF file format. </p>
<p>The second half of the chapter is about three simpler 
techniques for importing XML which require less comprehensive XML skills and no 
knowledge of ODF. The drawback is that the resulting document may be less 
'beautiful', often requiring some manual post-processing to remove unnecessary white 
space and data. </p>
<p>You'd be correct in thinking that Office can already import XML, but you may be 
disappointed with the results: a simple XML file, such as pay.xml shown below, is 
imported unchanged, as plain text: </p>
<?xml version="1.0"?>
<p><payments> 
  <payment> 
    <purpose>CD</purpose> 
    <amount>12.95</amount> 
    <tax>19.1234</tax> 
    <maturity>2008-03-01</maturity> 
  </payment> 
  <payment> 
    <purpose>DVD</purpose> 
    <amount>19.95</amount> 
    <tax>19.4321</tax> 
    <maturity>2008-03-02</maturity> 
  </payment> 
  <payment> 
    <purpose>Clothes</purpose> 
    <amount>99.95</amount> 
    <tax>18.5678</tax> 
    <maturity>2008-03-03</maturity> 
  </payment> 
  <payment> 
    <purpose>Book</purpose> 
    <amount>9.49</amount> 
    <tax>18.9876</tax> 
    <maturity>2008-03-04</maturity> 
  </payment> 
</payments> </p>
<p>Office offers many ways of loading XML through the "All files (<em>.</em>)" popdown list in 
the Open dialog. Figure 1 shows my selection of "Flat XML ODF Spreadsheet": </p>
<p><img alt="" src="images/50-Importing_XML-1.png" /></p>
<p>Figure 1. Selecting an XML Import Format. </p>
<p>Unfortunately, the result isn't a nice spreadsheet of the payments, but a Writer 
document containing all the data and XML tags. </p>
<p>Flat XML is for encoding an OpenDocument format (ODF) document as a single text 
file, which contrasts with how it's usually stored as a zipped folder of several files and 
sub-folders. pay.xml isn't a Flat XML file, and so Office drops back to treating it as 
plain text, and uses Writer to display it. </p>
<p>Incidentally, there are several Flat XML formats aimed at the different Office 
applications, Writer, Calc, Draw, and Impress.  </p>
<h2 id="1-filters-to-the-rescue">1.  Filters to the Rescue</h2>
<p>pay.xml can be opened as a spreadsheet with the help of an input filter. There are a 
few ways of writing these, as explained by Fridrich Strba in his blog post "Extending 
the Swiss Army knife - an overview about writing of filters for LibreOffice" 
(http://fridrich.blogspot.com/2013/08/extending-swiss-army-knife-overview.html). </p>
<p>The easiest way of implementing an XML input filter is with XSLT (eXtensible 
Stylesheet Language: Transformations). The filter is utilized by the XSLT processor 
inside Office to load and transform the XML, as illustrated in Figure 2. </p>
<p><img alt="" src="images/50-Importing_XML-2.png" /></p>
<p>Figure 2. Using an XSLT filter. </p>
<p>XSLT is designed for transforming XML into other textual formats; in this case, it 
will convert the simple XML used by pay.xml into the Flat XML used by Calc. </p>
<p>Office's  XSLT processor used to be Saxon (http://saxon.sourceforge.net/), a Java 
API, but was replaced in 2012 by the libxslt C library (http://xmlsoft.org/libxslt/). </p>
<p>This implements XSLT 1.0 with some extensions, so it's best to avoid using features 
from the newer XSLT 2.0. </p>
<p>One source for learning XLST in the context of ODF is: 
OASIS OpenDocument Essentials 
J. David Eisenberg, 2005 
http:// books.evc-cit.info/ 
The book includes a chapter on filters, and an appendix that overviews XSLT and 
XPath (XPath is used for locating parts of the input document for processing).  </p>
<p>Eisenberg's website has a free draft of the text, and all the examples and support code. </p>
<p>The site often seems to be offline, but the book can be found elsewhere, including at 
Lulu: http://www.lulu.com/shop/j-david-eisenberg/oasis-opendocument-
essentials/paperback/product-392512.html 
If you feel the need for more information on XSLT, a good text by the developer of 
Saxon is: 
XSLT 2.0 and XPath 2.0 Programmer's Reference 
Michael Kay 
Wrox Pub., May 2008, 4th Ed. </p>
<p>There's a somewhat shorter XSLT tutorial at W3Schools: 
http://www.w3schools.com/xml/xsl_intro.asp 
A useful forum post, "Create XSLT filters for import and export" 
(https://forum.openoffice.org/en/forum/viewtopic.php?t=3490), by user hol.sten 
contains XSLT import and export filters for pay.xml (in fact, it's his example). The 
filters are installed via Office's Tools &gt; "XML Filter Settings" menu item. Clicking on 
the "New" button of the filter settings window brings up a dialog containing two tabs 
shown in Figure 3. </p>
<p><img alt="" src="images/50-Importing_XML-3.png" /></p>
<p>Figure 3.  The XML Filter Settings Dialog Tabs. </p>
<p>Figure 3 shows that I've created a "Pay" filter set containing hol.sten's import and 
export filters stored in payImport.xsl and payExport.xsl. The import filter will convert 
XML to Flat XML for Calc, as stated in the "Application" field of the General tab. </p>
<p>After clicking "Ok", the Pay filter set is added to the settings window in Figure 4. </p>
<p><img alt="" src="images/50-Importing_XML-4.png" /></p>
<p>Figure 4. The Pay Filter in the Settings Window. </p>
<p>When pay.xml is opened, the Pay import filter appears in the Calc section of the "All 
Files (<em>.</em>) popdown list, as seen in Figure 5. </p>
<p><img alt="" src="images/50-Importing_XML-5.png" /></p>
<p>Figure 5. The Calc Pay Import Filter. </p>
<p>The "XML Payments" text in Figure 5 comes from the "Name of file type" textfield in 
the General tab of the dialog in Figure 3. </p>
<p>The resulting Calc document is shown in Figure 6. </p>
<p><img alt="" src="images/50-Importing_XML-6.png" /></p>
<p>Figure 6. Pay.xml Imported as a Spreadsheet. </p>
<h3 id="11-the-clubs-example">1.1.  The Clubs Example</h3>
<p>There's another nice XSLT import and export filter set in chapter 9 of Eisenberg's 
book. clubs.xml consists of a sequence of associations, each one made up of a 
sequence of clubs. A typical club entry looks like: </p>
<p><club id="Q21" charter="2002"> 
  <name>Castro Valley Wrestling Club</name> 
  <contact>Ron Maes</contact> 
  <location>Castro Valley</location> 
  <phone>510-555-1491</phone> 
  <email>cvwcron@example.com</email> 
  <age-groups type="KCJOW"/> 
  <info>Practices every Tuesday and Thursday at 5:00 P.M.  </p>
<pre><code>    at Castro Valley High School mat room.&lt;/info&gt;
</code></pre>
<p></club> </p>
<p>A helpful way of visualizing this information is with the XML editor at 
http://xmlgrid.net/, which renders it as in Figure 7. </p>
<p><img alt="" src="images/50-Importing_XML-7.png" /></p>
<p>Figure 7. Visualization of clubs.xml. </p>
<p>There are 17 associations; the first is called "BAWA" and contains 11 clubs 
Eisenberg's clubsImport.xsl and clubsExport.xsl filters are imported into Office using 
the "XML Filter Settings" dialog in Figure 8.  </p>
<p><img alt="" src="images/50-Importing_XML-8.png" /></p>
<p>Figure 8. The XML Filter Settings Dialog Again. </p>
<p>I've called the filter set "Clubs", and it uses clubsImport.xsl to produce Flat XML for 
Writer. There's also a Writer template called clubsTemplate.ott, which applies styles 
to the imported data. </p>
<p>When clubs.xml is opened, the Clubs import filter appears in the Writer section of the 
"All Files (<em>.</em>) popdown list, as in Figure 9. </p>
<p><img alt="" src="images/50-Importing_XML-9.png" /></p>
<p>Figure 9. The Writer Clubs Import Filter. </p>
<p>The start of the resulting Writer document looks like Figure 10. </p>
<p><img alt="" src="images/50-Importing_XML-10.png" /></p>
<p>Figure 10. Clubs.xml as a Writer Document. </p>
<h3 id="12-command-line-importing-and-exporting">1.2.  Command Line Importing (and Exporting)</h3>
<p>Import filter selection can be time-consuming because of the large number listed in 
"Open"s popdown list. A quicker approach is to call Office from the command line, 
supplying the filename and filter name as arguments. </p>
<p>Most of Office's command line arguments are listed at 
https://help.libreoffice.org/Common/Starting_the_Software_With_Parameters, and a 
few others when office.exe is invoked with the -h option. The filter commands are --
infilter and --convert-to, which I've wrapped up in two batch scripts called infilter.bat 
and convert.bat. </p>
<p>The hardest part of using these commands is the need to supply a filter name, which 
corresponds to the "Filter name" textfield string in the General tab of the XML Filter 
Settings dialog. The pay.xml import filter is "Pay", as shown in the left hand window 
in Figure 3; the clubs.xml filter is "Clubs", as in Figure 8.  </p>
<p>The infilter.bat script takes a filename and input filter name argument: 
infilter pay.xml "Pay" 
This causes Office to open pay.xml using the "Pay" import filter, creating the 
spreadsheet shown in Figure 6. </p>
<p>The convert.bat script takes an Office filename and conversion string as arguments. In 
the simple case, the string is the extension of the exported file. For example, the 
following exports the Writer document as XML: 
convert simpleText.odt xml 
If there are several filters to choose from (as there are for XML), then the default one 
is used; for this example the Flat XML exporter for Writer will be employed. If a 
different export filter is required then its name must be appended to the conversion 
string after a ":". For instance: 
convert payment.ods "xml:Pay" 
This exports the payments spreadsheet using the "Pay" filter, resulting in a file called 
payment.xml which has the same format as the original example at the start of the 
chapter. </p>
<h3 id="13-finding-a-filter-name">1.3.  Finding a Filter Name</h3>
<p>The calls to infilter.bat and convert.bat rely on the user knowing a filter's name (e.g. </p>
<p>"Pay" or "Clubs"). I knew these because I installed them, but what about the names of 
other filters in Office?<br />
A list of filters present in OpenOffice in 2007 can be found at 
https://wiki.openoffice.org/wiki/Framework/Article/Filter/FilterList_OOo_3_0. </p>
<p>However, a better approach is to call my FiltersInfo.java example which prints all the 
filters currently installed in Office, and some extra details about the "AbiWord", 
"Pay", and "Clubs" filters: </p>
<p>// in FiltersInfo.java 
public class FiltersInfo 
{ 
  public static void main(String[] args)<br />
  { 
    XComponentLoader loader = Lo.loadOffice(); </p>
<pre><code>// print the names of all the filters in Office 
String[] filterNms = Info.getFilterNames(); 
System.out.println("Filter Names"); 
Lo.printNames(filterNms, 3);

// print some extra info on 3 filters 
PropertyValue[] props = Info.getFilterProps("AbiWord"); 
Props.showProps("AbiWord Filter", props);

props = Info.getFilterProps("Pay"); 
Props.showProps("Pay Filter", props);

props = Info.getFilterProps("Clubs"); 
Props.showProps("Clubs Filter", props); 
int flags = (int) Props.getValue("Flags", props);

System.out.println("Filter flags: " +  
                       Integer.toHexString(flags)); 
System.out.println(" Import: " + Info.isImport(flags)); 
System.out.println(" Export: " + Info.isExport(flags));

Lo.closeOffice();
</code></pre>
<p>}   // end of main() </p>
<p>}  // end of FiltersInfo class </p>
<p>The output from FiltersInfo starts with a long list of  filter names:  </p>
<p>Filter Names 
No. of names: 235 
  "AbiWord"  "Apple Keynote"  "Apple Numbers" 
  "Apple Pages"  "BMP - MS Windows"  "BroadBand eBook" 
  "Calc MS Excel 2007 Binary"  "Calc MS Excel 2007 VBA XML" 
     : 
  "ClarisWorks_Draw"  "ClarisWorks_Impress"  "Clubs" 
     : 
  "Palm_Text_Document"  "PalmDoc"  "Pay" 
     : 
     : 
  "XHTML Draw File"  "XHTML Impress File"  "XHTML Writer File" 
  "XPM" </p>
<p>In the above list, I've included the lines that include the "Pay" and "Clubs" filter 
names. </p>
<p>The names are obtained by Info.getFilterNames(), which utilizes the FilterFactory 
service: </p>
<p>// in the Info class 
public static String[] getFilterNames() 
{ 
  XNameAccess na = Lo.createInstanceMCF(XNameAccess.class, 
                        "com.sun.star.document.FilterFactory"); 
  if (na == null) { 
    System.out.println("No Filter factory found"); 
    return null; 
  } 
  else 
    return na.getElementNames(); 
}  // end of getFilterNames() </p>
<p>Sometimes it's useful to know more about a filter than just it's name, such as whether 
it's for importing, exporting, or both. Additional information is available as an array 
of properties, by calling Info.getFilterProps() with the filter's name: </p>
<p>// in the Info class 
public static PropertyValue[] getFilterProps(String filterNm) 
{ 
  XNameAccess na = Lo.createInstanceMCF(XNameAccess.class, 
                           "com.sun.star.document.FilterFactory"); 
  if (na == null) { 
    System.out.println("No Filter factory found"); 
    return null; 
  } 
  else { 
    try { 
     return (PropertyValue[]) na.getByName(filterNm); 
    } 
    catch(Exception e) { 
      System.out.println("Could not find filter for " + filterNm); 
      return null; 
    } 
  } 
}  // end of getFilterProps() </p>
<p>getFilterProps() is called three times in FiltersInfo.java to retrieve details about the 
"AbiWord", "Pay", and "Clubs" filters. The output for "Clubs" is: </p>
<p>Properties for "Clubs Filter": 
  UserData: [com.sun.star.documentconversion.XSLTFilter, false, 
com.sun.star.comp.Writer.XMLOasisImporter, 
com.sun.star.comp.Writer.XMLOasisExporter, 
file:///C:/Users/Dell/Desktop/LibreOffice%20Tests/Filter%20Tests/club
sImport.xsl, 
file:///C:/Users/Dell/Desktop/LibreOffice%20Tests/Filter%20Tests/club
sExport.xsl, , ] 
  TemplateName: 
file:///C:/Users/Dell/AppData/Roaming/LibreOffice/4/user/template/Clu
bs/clubsTemplate.ott 
  Name: Clubs 
  Type: Clubs 
  UIComponent: 
  FileFormatVersion: 0 
  FilterService: com.sun.star.comp.Writer.XmlFilterAdaptor 
  DocumentService: com.sun.star.text.TextDocument 
  Flags: 524355 
  UINames: [    en-US = XML Clubs  ] 
  UIName: XML Clubs 
  Finalized: false 
  Mandatory: false </p>
<p>The UserData and TemplateName properties indicate that "Clubs" contains an import 
and export filter for Writer's Flat XML, and also a template. </p>
<p>Filter properties are explained in the online documentation for the FilterFactory 
service (use lodoc FilterFactory to access it), and also in the "Properties of a 
Filter" subsection of the "Integrating Import and Export Filters" section of chapter 6 
of the Developer's Guide (online at: 
https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Properties_of_
a_Filter, or use loGuide "Properties of a Filter"). </p>
<p>The most cryptic of the properties is the filter flags integer (524355 in the example 
above). It's actually a collection of bitwise OR'ed hexadecimals, and FiltersInfo.java 
shows how they can be accessed: </p>
<p>// part of FiltersInfo.java... </p>
<p>int flags = (int) Props.getValue("Flags", props); 
System.out.println("Filter flags: " + Integer.toHexString(flags)); 
           // print as a hexadecimal string </p>
<p>System.out.println(" Import: " + Info.isImport(flags)); 
System.out.println(" Export: " + Info.isExport(flags)); </p>
<p>The output is: </p>
<p>Filter flags: 80043 
 Import: true 
 Export: true </p>
<p>The hexadecimals that might appear in the flag are listed in the online "Properties of a 
Filter" subsection<br />
(https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Properties_of_
a_Filter). I've included a few isXXX() methods in the Info utilities class for testing for 
their presence. The above example reports that the "Clubs" filter contains both an 
import and export filter. </p>
<h2 id="2-using-filters-with-java">2.  Using Filters with Java</h2>
<p>Java contains an assortment of XML processing capabilities, grouped under the JAXP 
(Java API for XML Processing) heading. They include DOM and SAX parsing, XML 
schema validation, and XSLT transformation. The JDK's XSLT processor is Xalan 
(https://xml.apache.org/xalan-j/), which supports XSLT 1.0, and so is roughly 
equivalent to Office's libxslt library. This means that I can use the "Pay" and "Clubs" 
filters outside of Office by passing them to Java's Xalan processor. </p>
<p>There's a lot of information about JAXP online, including in Oracle's tutorial at 
https://docs.oracle.com/javase/tutorial/jaxp/. Also "XSLT 2.0 and XPath 2.0 
Programmer's Reference" by Michael Kay, which I mentioned earlier, includes an 
appendix on JAXP. </p>
<h3 id="21-importing-xml-with-java">2.1.  Importing XML with Java</h3>
<p>My ApplyInFilter.java example converts an XML file into an Office document in two 
steps. First it uses an XSLT import filter to generate Flat XML which it saves to a 
temporary file. The program then loads that file into Office with one of its Flat XML 
filters. The correct one is chosen by looking at the filename extension supplied for the 
final document. For example: 
run ApplyInFilter pay.xml payImport.xsl payment.ods 
pay.xml is transformed into Flat XML with payImport.xsl. Office isn't used since 
Java's XSLT processor is sufficient. However, at the next step the temporary file is 
loaded using Office's "Flat XML for Spreadsheets" filter. This filter is selected by 
noting the "ods" extension of payment.ods. </p>
<p>Another example: 
run ApplyInFilter clubs.xml clubsImport.xsl clubs.odt 
This converts clubs.xml into a Writer document stored in clubs.odt using the "Clubs" 
import filter. ApplyInFilter.java doesn't support templates, so the data saved to 
clubs.odt isn't nicely formatted like Figure 10. </p>
<p>The ApplyInFilter program: </p>
<p>public class ApplyInFilter 
{ 
  public static void main(String[] args)<br />
  { 
    if (args.length != 3) { 
      System.out.println("Usage: java ApplyInFilter<br />
                <XML fnm> <Flat XML import filter> <new ODF>"); 
      return; 
    } </p>
<pre><code>// convert the data to Flat XML 
String xmlStr = XML.applyXSLT(args[0], args[1]); 
if (xmlStr == null) { 
  System.out.println("Filtering failed"); 
  return; 
}

// save flat XML data in a temp file 
String flatFnm = FileIO.createTempFile("xml"); 
FileIO.saveString(flatFnm, xmlStr);

XComponentLoader loader = Lo.loadOffice();

// get the type of the output file 
String odfFnm = args[2]; 
String docType = Lo.ext2DocType( Info.getExt(odfFnm)); 
System.out.println("Doc type: " + docType);

// open temp file using the correct Flat XML filter 
XComponent doc = Lo.openFlatDoc(flatFnm, docType, loader); 
if (doc == null) 
  System.out.println("Document creation failed"); 
else { 
  GUI.setVisible(doc, true); 
  Lo.waitEnter(); 
  Lo.saveDoc(doc, odfFnm); 
  Lo.closeDoc(doc); 
} 
Lo.closeOffice();
</code></pre>
<p>}   // end of main() </p>
<p>}  // end of ApplyInFilter class </p>
<p>Java's XSLT processor is called by XML.applyXSLT(): </p>
<p>// in the XML class 
public static String applyXSLT(String xmlFnm, String xslFnm)<br />
{ 
  try { 
    TransformerFactory tf = TransformerFactory.newInstance(); 
    Source xslt = new StreamSource(new File(xslFnm)); 
    Transformer t = tf.newTransformer(xslt); </p>
<pre><code>System.out.println("Applying filter " + xslFnm +  
                                        " to " + xmlFnm); 
Source text = new StreamSource(new File(xmlFnm)); 
StreamResult result = new StreamResult(new StringWriter());

t.transform(text, result); 
return result.getWriter().toString();
</code></pre>
<p>} 
  catch(Exception e) 
  {  System.out.println("Unable to transform " + xmlFnm +<br />
                        " with " + xslFnm);<br />
     System.out.println("  " + e); 
     return null; 
  } 
}   // end of applyXSLT() </p>
<p>The resulting Flat XML is saved to a temporary file by ApplyInFilter.java, and then 
the document type of the output file is obtained: 
// part of ApplyInFilter.java... </p>
<p>String docType = Lo.ext2DocType( Info.getExt(odfFnm)); 
The docType string is "scalc" when the ODT file is payment.ods, and "swriter" for 
clubs.odt. </p>
<p>Lo.openFlatDoc() uses the document type to select the correct Flat XML filter, and 
passes it to Lo.openDoc() as the "FilterName" property: </p>
<p>// in the Lo class 
public static XComponent openFlatDoc(String fnm, String docType, 
                                       XComponentLoader loader) 
{ String nm = XML.getFlatFilterName(docType); 
  return openDoc(fnm, loader, Props.makeProps("FilterName", nm)); 
} </p>
<p>XML.getFlatFilterName() maps a document type to an appropriate Flat XML filter 
name: </p>
<p>// in the XML class 
public static String getFlatFilterName(String docType) 
{ 
  if (docType == Lo.WRITER_STR) 
    return "OpenDocument Text Flat XML"; 
  else if (docType == Lo.CALC_STR) 
    return "OpenDocument Spreadsheet Flat XML"; 
  else if (docType == Lo.DRAW_STR) 
    return "OpenDocument Drawing Flat XML"; 
  else if (docType == Lo.IMPRESS_STR) 
    return "OpenDocument Presentation Flat XML"; 
  else { 
    System.out.println("No Flat XML filter for this<br />
                        document type; using Flat text"); 
    return "OpenDocument Text Flat XML"; 
  } 
}  // end of getFlatFilterName() </p>
<h3 id="22-exporting-xml-with-java">2.2.  Exporting XML with Java</h3>
<p>My ApplyOutFilter.java example saves the specified document in Flat XML form to a 
temporary file. Then it applies an XSLT output filter to transform it into simple XML, 
which is saved in a new file. For example: 
run ApplyOutFilter payment.ods payExport.xsl payEx.xml 
payment.ods contains the spreadsheet shown in Figure 6, and the transformation fills 
payEx.xml with text almost identical to that on the first page of the chapter. </p>
<p>Another example: 
run ApplyOutFilter clubs.odt clubsExport.xsl clubsEx.xml 
clubs.odt must contain data formatted by the clubs template (i.e. like the example in 
Figure 10). This is necessary because clubsExport.xsl utilizes paragraph styles to 
decide how to change the text. </p>
<p>I had to slightly modify the style names used in Eisenberg's export filter. He utilized 
names containing spaces (e.g. "Club Name", "Club Code", "Age Groups", and "Club 
Info"), but Office automatically changes spaces inside names to "<em>20</em>". So I had to 
change the XSLT rules to refer to these names (i.e.  "Club_20_Name", 
"Club_20_Code", "Age_20_Groups", and "Club_20_Info"). </p>
<p>The ApplyOutFilter program: </p>
<p>public class ApplyOutFilter 
{ 
  public static void main(String[] args)<br />
  { 
    if (args.length != 3) { 
     System.out.println("Usage: java ApplyOutFilter <XML file><br />
                        <Flat XML export filter> <new XML file>"); 
      return; 
    } </p>
<pre><code>XComponentLoader loader = Lo.loadOffice(); 
XComponent doc = Lo.openDoc(args[0], loader); 
if (doc == null) { 
  System.out.println("Could not open document: " + args[0]); 
  Lo.closeOffice(); 
  return; 
}

// save flat XML data 
String flatFnm = FileIO.createTempFile("xml"); 
Lo.saveDoc(doc, flatFnm); 
Lo.closeDoc(doc);

// use XSLT to convert Flat XML into simple XML 
String filteredXML = XML.applyXSLT(flatFnm, args[1]); 
if (filteredXML == null) 
  System.out.println("Filtering failed"); 
else { 
  // indent, print, and save 
  String xmlStr = XML.indent2Str(filteredXML); 
  System.out.println(xmlStr); 
  FileIO.saveString(args[2], xmlStr); 
}

Lo.closeOffice();
</code></pre>
<p>}   // end of main() </p>
<p>}  // end of ApplyOutFilter class </p>
<p>At the end of ApplyOutFilter.java, the XML text in xmlStr is indented and printed. </p>
<p>The indention is carried out by XML.indent2Str() which calls XML.applyXSLT2str() 
with an indenting transformation loaded from indent.xsl: </p>
<p>// in the XML class 
// global 
private static final String INDENT_FNM = "indent.xsl"; 
  // for indenting XML tags, and adding newlines between tags </p>
<p>public static String indent2Str(String xmlStr)<br />
{  return applyXSLT2str(xmlStr,<br />
                    FileIO.getUtilsFolder()+INDENT_FNM); 
} </p>
<p>applyXSLT2str() is a variant of XML.applyXSLT() which reads XML from a string 
rather than a file. </p>
<h2 id="3-alternatives-to-xslt-filters">3.  Alternatives to XSLT Filters</h2>
<p>The obvious drawback of the XSLT filter approach is that filter writing requires the 
programmer to be knowledgable about XSLT, XPath, and the details of the Flat XML 
format. </p>
<p>Another way to write import and export filter is to utilize the ImportFilter and 
ExportFilter services in the com.sun.star.document module, which are shown in </p>
<p><img alt="" src="images/50-Importing_XML-11.png" /></p>
<p>Figure 11. </p>
<p><img alt="" src="images/50-Importing_XML-11.png" /></p>
<p>Figure 11. The ImportFilter and ExportFilter Services. </p>
<p>These services allow the implementation of non-XML based transformations by 
utilizing the ImportFilter and ExportFilter services rather than their XMLImportFilter 
and XMLExportFilter subclasses. The subclasses employ SAX, an event-driven way 
of parsing XML.  </p>
<p>If you're interested in using ImportFilter and ExportFilter, the Developer's guide gives 
some details in the "Integrating Import and Export Filters" section of chapter 6 on 
"Office Development". The information is also online, starting at 
https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Integrating_Im
port_and_Export_Filters, or use loGuide "Import and Export Filters". </p>
<p>But I'm not going to use these services due to their complexity, and I'm about to stop 
using XSLT as well. Instead I'm going to look at three easier ways to import XML 
into Office: </p>
<h2 id="1-data-extraction-by-dom-parsing">1.  Data extraction by DOM parsing;</h2>
<h2 id="2-node-and-attribute-data-extraction-as-labeled-strings">2.  Node and attribute data extraction as labeled strings;</h2>
<h2 id="3-jaxb-conversion-of-xml-to-java-objects">3.  JAXB conversion of XML to Java objects.</h2>
<p>The drawback of these simpler approaches is that the imported data will usually need 
some post-processing to make it look as good as import filter results. </p>
<h3 id="31-data-extraction-by-dom-parsing">3.1.  Data Extraction by DOM Parsing</h3>
<p>Document Object Model (DOM) parsing converts an XML document into a tree of 
nodes; the three main types are: 
 Elements; 
 Attributes; 
 The data/values held by the elements and attributes. </p>
<p>The DOM API is quite low-level, supporting functions such as getFirstChild() and 
getNextSibling() in Java's Node class. This motivated the introduction of XPath, and 
other tree models such as JDOM. Fortunately, I won't be needing those more 
advanced features. </p>
<p>Nodes are found by searching for their name. When a possible match is discovered, 
the node's children usually need to be examined to determine the node type. For 
instance, node data has the type Node.TEXT_NODE, while an attribute has the type 
Node.ATTRIBUTE.  </p>
<p>There are many online tutorials on Java and DOM, such as Oracle's at 
https://docs.oracle.com/javase/tutorial/jaxp/dom. Two other good ones are mkyong's 
starting at http://www.mkyong.com/tutorials/java-xml-tutorials/ and "Easy DOM 
Parsing in Java" by Eric Bruno at http://www.drdobbs.com/jvm/easy-dom-parsing-in-
java/231002580. I've 'borrowed' some of Bruno's DOM functions for my XML.java 
support class, and his company.xml example. </p>
<p>A textbook on Java and XML: 
Pro XML Development with Java Technology 
Ajay and Deepak Vohra 
Apress, 2006 
The company.xml file contains details about three companies: </p>
<?xml version="1.0" encoding="UTF-8" ?>
<p><Companies> 
  <Company> 
    <Name>ABC</Name> 
    <Executive type="CEO"> 
        <LastName>Smith</LastName> 
        <FirstName>Jim</FirstName> 
        <street>123 Broad Street</street> 
        <city>Manchester</city> 
        <state>Cheshire</state> 
        <zip>11234</zip> 
    </Executive> 
  </Company> </p>
<p><Company> 
    <Name>NBC</Name> 
    <Executive type="President"> 
        <LastName>Jones</LastName> 
        <FirstName>Lucy</FirstName> 
        <street>23 Bradford St</street> 
        <city>Asbury</city> 
        <state>Lincs</state> 
        <zip>33451</zip> 
    </Executive> 
  </Company> </p>
<p><Company> 
    <Name>BBC</Name> 
    <Executive type="Boss"> 
        <LastName>Singh</LastName> 
        <FirstName>Oxley</FirstName> 
        <street>16d Towers</street> 
        <city>Wimbledon</city> 
        <state>London</state> 
        <zip>77392</zip> 
    </Executive> 
  </Company> 
</Companies> </p>
<p>When writing DOM code, it helps to visualize its structure. One way is to load the file 
into the editor at http://xmlgrid.net/, which displays the tree-like structure in Figure 
12. </p>
<p><img alt="" src="images/50-Importing_XML-12.png" /></p>
<p>Figure 12. The Tree Structure of company.xml. </p>
<p>Clicking on the arrow heads expand or contract the tree view. </p>
<p>My ExamineCompany.java example loads this data as a DOM tree, and extracts 
various information: </p>
<p>// in ExamineCompany.java 
public class ExamineCompany 
{ 
  public static void main(String[] args) throws Exception 
  { 
    Document doc = XML.loadDoc("company.xml"); 
    NodeList root = doc.getChildNodes();  // get the document's root </p>
<pre><code>// move down the tree to the executive in the first company node 
Node comps = XML.getNode("Companies", root); 
Node comp = XML.getNode("Company", comps.getChildNodes()); 
Node exec = XML.getNode("Executive", comp.getChildNodes());

// print the executive's data 
String execType = XML.getNodeAttr("type", exec); 
NodeList exNodes = exec.getChildNodes(); 
String lastName = XML.getNodeValue("LastName", exNodes); 
String firstName = XML.getNodeValue("FirstName", exNodes); 
String street = XML.getNodeValue("street", exNodes); 
String city = XML.getNodeValue("city", exNodes); 
String state = XML.getNodeValue("state", exNodes); 
String zip = XML.getNodeValue("zip", exNodes);

System.out.println(execType); 
System.out.println(lastName + ", " + firstName); 
System.out.println(street); 
System.out.println(city + ", " + state + " " + zip);

// get all the data in the tree for a given node/tag name 
NodeList lnNodes = doc.getElementsByTagName("LastName"); 
ArrayList&lt;String&gt; lastnames = XML.getNodeValues(lnNodes); 
System.out.println("All lastnames:"); 
for(String lastname: lastnames) 
  System.out.println("  " + lastname);
</code></pre>
<p>}  // end of main() 
}  // end of ExamineCompany class </p>
<p>The program outputs details about the first company, and the lastnames of all the 
company bosses: </p>
<p>CEO 
Smith, Jim 
123 Broad Street 
Manchester, Cheshire 11234 
All lastnames: 
  Smith 
  Jones 
  Singh </p>
<p>XML.getNode() searches through a list of nodes, and returns the first with the 
specified tag name: </p>
<p>// in the XML class 
public static Node getNode(String tagName, NodeList nodes)<br />
{ 
  for (int i = 0; i &lt; nodes.getLength(); i++) { 
    Node node = nodes.item(i); 
    if (node.getNodeName().equalsIgnoreCase(tagName)) 
      return node; 
  } 
  return null; 
}  // end of getNode() </p>
<p>XML.getNodeValue() looks for a node in a list based on its tag name, and extracts the 
data stored beneath that node.  </p>
<p>// in the XML class 
public static String getNodeValue(String tagName, NodeList nodes)<br />
{ 
  if (nodes == null) 
    return ""; 
  for (int i = 0; i &lt; nodes.getLength(); i++) { 
    Node n = nodes.item(i); 
    if (n.getNodeName().equalsIgnoreCase(tagName)) 
      return getNodeValue(n); 
  } 
  return ""; 
}  // end of getNodeValue() </p>
<p>The second version of XML.getNodeValue() retrieves the text from a node's 
TEXT_NODE child (if there is one): </p>
<p>// in the XML class 
public static String getNodeValue(Node node)<br />
{ 
  if (node == null) 
    return ""; 
  NodeList childNodes = node.getChildNodes(); 
  for (int i = 0; i &lt; childNodes.getLength(); i++) { 
    Node n = childNodes.item(i); 
    if (n.getNodeType() == Node.TEXT_NODE) 
      return n.getNodeValue().trim(); 
  } 
  return ""; 
}  // end of getNodeValue() </p>
<p>XML.getNodeValues() constructs a list of the data stored in all the supplied nodes: </p>
<p>// in the XML class 
public static ArrayList<String> getNodeValues(NodeList nodes)<br />
{ 
  if (nodes == null) 
    return null; 
  ArrayList<String> vals = new ArrayList<String>(); 
  for (int i = 0; i &lt; nodes.getLength(); i++) { 
     String val = getNodeValue(nodes.item(i)); 
     if (val != null) 
       vals.add(val); 
  } 
  return vals; 
}  // end of getNodeValues() </p>
<p>XML.getNodeAttr() extracts data from a node's attribute: </p>
<p>// in the XML class 
public static String getNodeAttr(String attrName, Node node)<br />
{ 
  if (node == null) 
    return ""; 
  NamedNodeMap attrs = node.getAttributes(); 
  if (attrs == null) 
    return ""; 
  for (int i = 0; i &lt; attrs.getLength(); i++) { 
    Node attr = attrs.item(i); 
    if (attr.getNodeName().equalsIgnoreCase(attrName)) 
      return attr.getNodeValue().trim(); 
  } 
  return ""; 
}  // end of getNodeAttr() </p>
<p>Converting XML to Spreadsheet Data 
It's fairly easy to map XML data into a spreadsheet format of rows and columns. </p>
<p>Consider pay.xml from earlier: </p>
<?xml version="1.0"?>
<p><payments> 
  <payment> 
    <purpose>CD</purpose> 
    <amount>12.95</amount> 
    <tax>19.1234</tax> 
    <maturity>2008-03-01</maturity> 
  </payment> </p>
<p><payment> 
    <purpose>DVD</purpose> 
    <amount>19.95</amount> 
    <tax>19.4321</tax> 
    <maturity>2008-03-02</maturity> 
  </payment> </p>
<p><payment> 
    <purpose>Clothes</purpose> 
    <amount>99.95</amount> 
    <tax>18.5678</tax> 
    <maturity>2008-03-03</maturity> 
  </payment> </p>
<p><payment> 
    <purpose>Book</purpose> 
    <amount>9.49</amount> 
    <tax>18.9876</tax> 
    <maturity>2008-03-04</maturity> 
  </payment> 
</payments> </p>
<p>It can be viewed as a sequence of payment objects, each containing four fields 
(purpose, amount, tax, and maturity). Each  payment object can be mapped to a 
spreadsheet row, and its fields to four columns in that row. This format can be 
represented by a 2D array, which is easily constructed using the DOM API. </p>
<p>My CreatePay.java example utilizes XML.getAllNodeValues() to build a 2D array 
from the pay.xml data, and calls Calc.setArray() to add the data to a new Calc 
document: </p>
<p>// in CreatePay.java 
public class CreatePay<br />
{ 
  public static void main(String args[]) 
  { 
    Document xdoc = XML.loadDoc("pay.xml"); 
    NodeList pays = xdoc.getElementsByTagName("payment"); 
    if (pays == null) 
      return; </p>
<pre><code>Object[][] data = XML.getAllNodeValues(pays,  
         new String[]{"purpose", "amount", "tax", "maturity"});  
Lo.printTable("payments", data);

XComponentLoader loader = Lo.loadOffice(); 
XSpreadsheetDocument doc = Calc.createDoc(loader); 
if (doc == null) { 
  System.out.println("Document creation failed"); 
  Lo.closeOffice(); 
  return; 
} 
GUI.setVisible(doc, true); 
XSpreadsheet sheet = Calc.getSheet(doc, 0);

Calc.setArray(sheet, "A1", data);

// Lo.saveDoc(doc, "payCreated.ods"); 
Lo.waitEnter(); 
Lo.closeDoc(doc); 
Lo.closeOffice();
</code></pre>
<p>}  // end of main() </p>
<p>}  // end of CreatePay class </p>
<p>The list of payment nodes is obtained using: 
// part of CreatePay.java... </p>
<p>NodeList pays = xdoc.getElementsByTagName("payment"); 
The 2D array of payment data is constructed by: </p>
<p>// part of CreatePay.java... </p>
<p>Object[][] data = XML.getAllNodeValues(pays,<br />
        new String[]{"purpose", "amount", "tax", "maturity"});  </p>
<p>The first argument of getAllNodeValues() is the list of nodes to be scanned, and the 
second parameter is an array of tag names. The named nodes are assumed to be 
children of each  node in the list, and their data becomes one row in the 2D array. The 
method's code: </p>
<p>// in the XML class 
public static Object[][] getAllNodeValues(NodeList rowNodes,<br />
                                          String[] colIDs)<br />
{ int numRows = rowNodes.getLength(); 
  int numCols = colIDs.length; 
  Object[][] data = new Object[numRows+1][numCols]; </p>
<p>// put column names in first row of array 
  for (int col = 0; col &lt; numCols; col++) 
    data[0][col] = Lo.capitalize( colIDs[col]); </p>
<p>for (int i = 0; i &lt; numRows; i++) { 
    // extract column data for ith row 
    NodeList colNodes = rowNodes.item(i).getChildNodes(); 
    for (int col = 0; col &lt; numCols; col++) 
       data[i+1][col] = getNodeValue(colIDs[col], colNodes); 
  } 
  return data; 
}  // end of getAllNodeValues() </p>
<p>XML.getAllNodeValues() also adds a header row to the array made up of the tag 
names.  </p>
<p>The resulting table is printing by Lo.printTables(): </p>
<p>-- payments ---------------- 
  Purpose  Amount  Tax  Maturity 
  CD  12.95  19.1234  2008-03-01 
  DVD  19.95  19.4321  2008-03-02 
  Clothes  99.95  18.5678  2008-03-03 
  Book  9.49  18.9876  2008-03-04 </p>
<hr />
<p>Calc.setArray() adds the table to the spreadsheet, which ends up like Figure 13. </p>
<p><img alt="" src="images/50-Importing_XML-13.png" /></p>
<p>Figure 13. The Spreadsheet Generated by CreatePay.java. </p>
<p>XML.getAllNodeValues() doesn't always produce such good results, as illustrated by 
the CreateAssoc.java example which converts part of clubs.xml into a spreadsheet. </p>
<p>As explained earlier, clubs.xml consists of a sequence of associations, with each one 
made up of a sequence of clubs. The most natural spreadsheet mapping would be to 
assign each association to its own sheet, and convert each club into a row on that 
sheet.  </p>
<p>A club consists of seven elements and two attributes, as seen in the following 
example: </p>
<p><club id="Q21" charter="2002"> 
  <name>Castro Valley Wrestling Club</name> 
  <contact>Ron Maes</contact> 
  <location>Castro Valley</location> 
  <phone>510-555-1491</phone> 
  <email>cvwcron@example.com</email> 
  <age-groups type="KCJOW"/> 
  <info>Practices every Tuesday and Thursday at 5:00 P.M.  </p>
<pre><code>    at Castro Valley High School mat room.&lt;/info&gt;
</code></pre>
<p></club> </p>
<p>Probably the best spreadsheet representation would be to use nine columns, so the 
attributes could be listed. This approach is employed by the xmlgrid.net website as 
shown in Figure 14. </p>
<p><img alt="" src="images/50-Importing_XML-14.png" /></p>
<p>Figure 14. Part of the Clubs Information. </p>
<p>Unfortunately, XML.getAllNodeValues() as currently coded doesn't extract attribute 
information, so the id and charter data will be missed. </p>
<p>The CreateAssoc.java example loads clubs.xml, and selects the first association. Its 
list of clubs is passed to XML.getAllNodeValues() for conversion into an array. The 
complete program is: </p>
<p>// in CreateAssoc.java 
public class CreateAssoc<br />
{ 
  public static void main(String args[]) 
  { 
    Document xdoc = XML.loadDoc("clubs.xml"); 
    NodeList root = xdoc.getChildNodes(); </p>
<pre><code>// get the first association 
Node cdb = XML.getNode("club-database", root); 
Node assoc1 = XML.getNode("association", cdb.getChildNodes()); 
NodeList clubs = assoc1.getChildNodes();

// convert clubs information into an array 
Object[][] data = XML.getAllNodeValues(clubs,  
  new String[]{"name", "contact", "location", "phone", "email"});  
Lo.printTable("clubs", data);

XComponentLoader loader = Lo.loadOffice(); 
XSpreadsheetDocument doc = Calc.createDoc(loader); 
if (doc == null) { 
  System.out.println("Document creation failed"); 
  Lo.closeOffice(); 
  return; 
} 
GUI.setVisible(doc, true); 
XSpreadsheet sheet = Calc.getSheet(doc, 0); 
Calc.setArray(sheet, "A1", data);

// Lo.saveDoc(doc, "clubsCreated.ods"); 
Lo.waitEnter(); 
Lo.closeDoc(doc); 
Lo.closeOffice();
</code></pre>
<p>}  // end of main() </p>
<p>}  // end of CreateAssoc class </p>
<p>XML.getAllNodeValues() only requests data for five of the seven elements ("name", 
"contact", "location", "phone", "email") to reduce the information returned. The 
resulting spreadsheet is shown in Figure 15. </p>
<p><img alt="" src="images/50-Importing_XML-15.png" /></p>
<p>Figure 15. Part of the Spreadsheet Generated by CreateAssoc.java. </p>
<p>An obvious issue is the empty rows between the clubs data, caused by the simple 
XML.getAllNodeValues() implementation. It assumes that every node supplies one 
row of data because of its data element child. Howevere, each club also contains 
attributes which adds an extra empty row to the output. </p>
<h3 id="32-node-and-attribute-data-extraction-as-labeled-strings">3.2.  Node and Attribute Data Extraction as Labeled Strings</h3>
<p>Not all XML data can be so easily mapped to a 2D format, especially collections such 
as weather.xml: </p>
<?xml version="1.0" encoding="UTF-8"?>
<p><current> 
    <city id="1610780" name="Hat Yai"> 
        <coord lat="7.01" lon="100.48"/> 
        <country>TH</country> 
        <sun rise="2017-01-01T23:30:31" set="2017-01-02T11:14:18"/> 
    </city> 
    <temperature max="25" min="25" unit="metric" value="25"/> 
    <humidity unit="%" value="94"/> 
    <pressure unit="hPa" value="1011"/> 
    <wind> 
        <speed name="Gentle Breeze" value="3.6"/> 
        <gusts/> 
        <direction code="NNE" name="North-northeast" value="30"/> 
    </wind> 
    <clouds name="broken clouds" value="75"/> 
    <visibility value="5000"/> 
    <precipitation mode="no"/> 
    <weather icon="10n" number="501" value="moderate rain"/> 
    <lastupdate value="2017-01-02T15:30:00"/> 
</current> </p>
<p>This data was downloaded from OpenWeatherMap using the API at 
http://api.openweathermap.org. Unlike pay.xml or clubs.xml there's no sequence of 
objects that would naturally become rows of a spreadsheet. In addition, the data is 
mostly represented by attributes rather than text nodes. </p>
<p>In situations like this, a good general approach is to convert the XML to simpler text, 
removing XML labels except for the element and attribute names. As a result, my 
ExtractXMLInfo.java example produces the following output when applied to 
weather.xml: </p>
<p>current 
  city  id= "1610780"  name= "Hat Yai" 
    coord  lat= "7.01"  lon= "100.48" 
    country: "TH" 
    sun  rise= "2017-01-01T23:30:31"  set= "2017-01-02T11:14:18" </p>
<p>temperature  max= "25"  min= "25"  unit= "metric"  value= "25" 
  humidity  unit= "%"  value= "94" 
  pressure  unit= "hPa"  value= "1011" 
  wind 
    speed  name= "Gentle Breeze"  value= "3.6" 
    gusts 
    direction  code= "NNE"  name= "North-northeast"  value= "30" </p>
<p>clouds  name= "broken clouds"  value= "75" 
  visibility  value= "5000" 
  precipitation  mode= "no" 
  weather  icon= "10n"  number= "501"  value= "moderate rain" 
  lastupdate  value= "2017-01-02T15:30:00" </p>
<p>Line indentation is retained, and is utilized when the data is loaded into Office. </p>
<p>As another example, consider pay.xml which ExtractXMLInfo.java converts into: </p>
<p>payments 
  payment 
    purpose: "CD" 
    amount: "12.95" 
    tax: "19.1234" 
    maturity: "2008-03-01" </p>
<p>payment 
    purpose: "DVD" 
    amount: "19.95" 
    tax: "19.4321" 
    maturity: "2008-03-02" </p>
<p>payment 
    purpose: "Clothes" 
    amount: "99.95" 
    tax: "18.5678" 
    maturity: "2008-03-03" </p>
<p>payment 
    purpose: "Book" 
    amount: "9.49" 
    tax: "18.9876" 
    maturity: "2008-03-04" </p>
<p>The elements and attributes with data are highlighted by adding  a ":" or "=" after 
their names. Also, the data is always doubly quoted. </p>
<p>ExtractXMLInfo.java travels over the DOM tree, printing what it finds to a text file: </p>
<p>// in ExtractXMLInfo.java 
public static void main(String[] args) throws Exception 
{ 
  if (args.length != 1) { 
    System.out.println("Usage: run ExtractXMLInfo <XML file>"); 
    return; 
  } 
  Document doc = XML.loadDoc(args[0]); 
  if (doc == null) 
    return; </p>
<p>String fname = Info.getName(args[0]); 
  String outFnm = fname + "XML.txt"; 
  System.out.println("Writing XML data from " + args[0] +<br />
                                           " to " + outFnm); 
  PrintWriter pw = new PrintWriter(new FileWriter(outFnm)); </p>
<p>NodeList root = doc.getChildNodes(); 
  // there may be multiple trees; visit each one 
  for (int i = 0; i &lt; root.getLength(); i++) { 
    visitNode(pw, root.item(i), ""); 
    pw.write("\n"); 
  } 
  pw.close(); 
}  // end of main() </p>
<p>visitNode() prints the node's tag, any attribute data, any text child node data, and 
recursively visits the rest of the node's children: </p>
<p>// part of ExtractXMLInfo.java 
private static void visitNode(PrintWriter pw, Node node, String ind) 
{ 
  pw.write(ind + node.getNodeName()); 
  visitAttrs(pw, node); </p>
<p>// examine all the child nodes 
  NodeList nodeList = node.getChildNodes(); 
  for (int i = 0; i &lt; nodeList.getLength(); i++) { 
    Node child = nodeList.item(i); 
    if (child.getNodeType() == Node.TEXT_NODE) { 
      String trimmedVal = child.getNodeValue().trim(); 
      if (trimmedVal.length() == 0) 
        pw.write("\n"); 
      else 
        pw.write(": \"" + trimmedVal + "\""); 
           // element names with values end with ':' 
    } 
    else if (child.getNodeType() == Node.ELEMENT_NODE) 
      visitNode(pw, child, ind+"  "); 
  } 
} // end of visitNode() </p>
<p>visitAttrs() prints attribute names and data: </p>
<p>// part of ExtractXMLInfo.java 
private static void visitAttrs(PrintWriter pw, Node node)<br />
{ 
  NamedNodeMap attrs = node.getAttributes(); 
  if (attrs != null) { 
    for (int i = 0; i &lt; attrs.getLength(); i++) { 
      Node attr = attrs.item(i); 
      pw.write("  " + attr.getNodeName() + "= \"" +<br />
                             attr.getNodeValue() + "\""); 
           // attribute names end with '=' 
    } 
  } 
}  // end of visitAttrs() </p>
<p>When ExtractXMLInfo.java has finished stripping the XML, the next stage is to call 
BuildXMLSheet.java to load the text into Office as a Calc sheet. This is done by 
converting it into a 2D array which is added to the spreadsheet by Calc.setArray().  </p>
<p>The main() function of BuildXMLSheet.java calls getData() to create the array: </p>
<p>// in BuildXMLSheet.java 
public static void main(String[] args) 
{ 
  if (args.length != 1) { 
    System.out.println("Usage: run BuildXMLSheet <XML textfile>"); 
    return; 
  } </p>
<p>Object[][] data = getData(args[0]); 
  Lo.printTable(args[0] + " data", data); </p>
<p>XComponentLoader loader = Lo.loadOffice(); 
  XSpreadsheetDocument doc = Calc.createDoc(loader); 
  if (doc == null) { 
    System.out.println("Document creation failed"); 
    Lo.closeOffice(); 
    return; 
  } 
  GUI.setVisible(doc, true); 
  Lo.delay(2000); 
  XSpreadsheet sheet = Calc.getSheet(doc, 0); 
  Calc.setArray(sheet, "A1", data); </p>
<p>// Lo.saveDoc(doc, "createdSS.ods"); 
  Lo.waitEnter(); 
    Lo.closeDoc(doc); 
    Lo.closeOffice(); 
  }  // end of main() </p>
<p>getData() builds the array in two steps: initially a list of differently sized arrays is 
created, one for each input line. Then the list is converted into a 2D array where every 
row has the same length. </p>
<p>// part of BuildXMLSheet.java 
private static Object[][] getData(String fnm) 
{ 
  int maxCols = 0;    // max number of columns across all rows </p>
<p>// each input line is stored as an array inside a list 
  ArrayList<Object[]> rows = new ArrayList<Object[]>(); </p>
<p>System.out.println("Reading data from " + fnm); 
  try { 
    BufferedReader br = new BufferedReader(new FileReader(fnm)); 
    String line; 
    while ((line = br.readLine()) != null) { 
       Object[] toks = splitLine(line); 
           // read a line as an array of tokens (strings) 
      if (toks.length &gt; 0) 
        rows.add(toks); 
      if (toks.length &gt; maxCols) 
        maxCols = toks.length; 
    } 
  } 
  catch(IOException e) { 
    System.out.println("Could not read " + fnm); 
    return null; 
  } </p>
<p>// convert list of different length arrays into a 
  // fixed length 2D array 
  Object[][] data = new Object[rows.size()][maxCols]; 
  for (int r = 0; r &lt; rows.size(); r++) { 
    Object[] row = rows.get(r); 
    for (int c = 0; c &lt; maxCols; c++) { 
      if (c &gt;= row.length) 
        data[r][c] = "";   // pad out array row with empty strings 
      else 
        data[r][c] = row[c]; 
    } 
  } 
  return data; 
}  // end of getData() </p>
<p>splitLine() converts an input line into an array of tokens.  </p>
<p>// part of BuildXMLSheet.java 
private static String[] splitLine(String ln) 
{<br />
  ln += " "; // To detect last token when not quoted... </p>
<p>boolean inQuote = false; 
  boolean isIndenting = true; 
  int numSpaces = 0; </p>
<p>StringBuilder word = new StringBuilder(); 
  ArrayList<String> toks = new ArrayList<String>(); 
               // used to store tokens for the final array </p>
<p>for (int i = 0; i &lt; ln.length(); i++) { 
    char ch = ln.charAt(i); </p>
<pre><code>if (ch != ' ' &amp;&amp; isIndenting) 
  isIndenting = false;

if (ch == ' ' &amp;&amp; isIndenting) { 
  numSpaces++; 
  if (numSpaces%2 == 0) 
    toks.add("");  // convert two space indent into "" 
} 
else if (ch == '\"' || ch == ' ' &amp;&amp; !inQuote) { 
  // treat a double quoted string as one token 
  if (ch == '\"') 
    inQuote = !inQuote; 
  if (!inQuote &amp;&amp; word.length() &gt; 0) { 
    char lastCh = word.charAt(word.length()-1); 
    if ((lastCh == ':') || (lastCh == '=')) 
      // strip element and attribute assignment symbols 
      word.deleteCharAt(word.length()-1); 
    toks.add(word.toString()); 
    word.delete(0, word.length()); 
  } 
}  
else 
  word.append(ch);
</code></pre>
<p>} 
  return toks.toArray(new String[toks.size()]); 
}  // end of splitLine() </p>
<p>Every two spaces at the start of a line is stored as an empty string in the row array. </p>
<p>These strings will later occupy spreadsheet cells at the start of a row, causing the 
actual data to be 'indented' to cells further to the right. </p>
<p>Special care is taken to treat a doubly quoted string as a single token, and any word 
ending with ':' or '=' has that character stripped away. These characters signify that the 
element or attribute name has associated data. </p>
<p>Figure 16 shows how the weather data is loaded as a spreadsheet by 
BuildXMLSheet.java. </p>
<p><img alt="" src="images/50-Importing_XML-16.png" /></p>
<p>Figure 16. BuildXMLSheet Applied to Weather Data. </p>
<p>Figure 17 shows the results for the payments data. </p>
<p><img alt="" src="images/50-Importing_XML-17.png" /></p>
<p>Figure 17. BuildXMLSheet Applied to Payments Data. </p>
<h3 id="33-jaxb-conversion-of-xml-to-java-objects">3.3.  JAXB Conversion of XML to Java Objects</h3>
<p>Java Architecture for XML Binding (JAXB) provides methods for unmarshalling 
(converting) XML documents into Java classes and objects, and for marshalling Java 
objects back into XML documents. I'm interested in the unmarshalling parts so data 
can be passed to Office as Java objects rather than as XML. </p>
<p>Most of the magic of the XML-to-Java conversion is performed by Java's xjc.exe tool 
which comes as part of the JDK (you'll find it in %java_home%\bin\ on Windows). </p>
<p>xjc processes an XML schema (an XSD file)  rather than XML since the schema 
contains information about the XML's underlying structure. </p>
<p>The good news is that there are websites, such as freeformatter.com, which can<br />
generate XSD from supplied XML (http://www.freeformatter.com/xsd-
generator.html). I employed its "Salami slice" translator so that the Java code 
generated later by xjc is a bit simpler to read. freeformatter.com converted pay.xml 
into the following XSD: </p>
<p><xs:schema attributeFormDefault="unqualified" 
elementFormDefault="qualified" 
xmlns:xs="http://www.w3.org/2001/XMLSchema"> 
  <xs:element name="purpose" type="xs:string"/> 
  <xs:element name="amount" type="xs:float"/> 
  <xs:element name="tax" type="xs:float"/> 
  <xs:element name="maturity" type="xs:date"/> 
  <xs:element name="payment"> 
    <xs:complexType> 
      <xs:sequence> 
        <xs:element ref="purpose"/> 
        <xs:element ref="amount"/> 
        <xs:element ref="tax"/> 
        <xs:element ref="maturity"/> 
      </xs:sequence> 
    </xs:complexType> 
  </xs:element> 
  <xs:element name="payments"> 
    <xs:complexType> 
      <xs:sequence> 
        <xs:element ref="payment"<br />            maxOccurs="unbounded" minOccurs="0"/> 
      </xs:sequence> 
    </xs:complexType> 
  </xs:element> 
</xs:schema> </p>
<p>The schema gives the names and types for each field in a payment object, and makes 
payments a sequence of payment objects.  </p>
<p>A good tutorial on XSD can be found at w3schools.com: 
http://www.w3schools.com/Xml/schema_intro.asp 
If the resulting schema is stored in pay.xsd, then xjc generates Java classes like so: 
xjc -p Pay pay.xsd 
The p option supplies a package name which causes the potentially numerous classes 
to be stored in a folder of that name. Details about xjc can be found at 
http://docs.oracle.com/javase/6/docs/technotes/tools/share/xjc.html, or by calling xjc -
help. </p>
<p>Three classes are written to the Pay\ folder: Payments.java, Payment.java, and 
ObjectFactory.java. The first two are Java version of the XML elements, while 
ObjectFactory is used to create the Java objects at runtime. Figure 18 shows class 
diagrams for the code. </p>
<p><img alt="" src="images/50-Importing_XML-18.png" /></p>
<p>Figure 18. The Payments Class Diagrams. </p>
<p>As you might expect, the XML sequence of Payment objects inside Payments is 
implemented as a list in Java. </p>
<p>The details of the ObjectFactory aren't important, but the get/set methods in the 
Payments and Payment classes will be useful. My UnmarshallPay.java example 
shows how to use these classes: </p>
<p>// in UnmarshallPay.java 
import java.io.<em>; 
import java.util.</em>; 
import javax.xml.bind.<em>; 
import Pay.</em>;   // the package for the Pay classes </p>
<p>public class UnmarshallPay<br />
{ 
  public static void main(String[] args)<br />
  { 
    try { 
      // initialize the Payments objects using pay.xml 
      JAXBContext jaxbContext =<br />
               JAXBContext.newInstance(Payments.class); 
      Unmarshaller jaxbUnmarshaller =<br />
               jaxbContext.createUnmarshaller(); 
      Payments pays = (Payments) jaxbUnmarshaller.unmarshal(<br />
                                     new File("pay.xml")); </p>
<pre><code>  List&lt;Payment&gt; payList = pays.getPayment();

  // print payment names and amounts 
  System.out.println("Payments"); 
  for(Payment p : payList) 
    System.out.println("  " + p.getPurpose() +  
                       ": " + p.getAmount()); 
}  
catch (JAXBException e) { 
  e.printStackTrace(); 
}
</code></pre>
<p>}  // end of main() </p>
<p>}  // end of UnmarshallPay class </p>
<p>main() creates an Unmarshaller object for the Payments class, which is initialized 
with data from pay.xml. It then iterates through the Payment objects and prints their 
purpose and amount fields. The output is: </p>
<p>Payments 
  CD: 12.95 
  DVD: 19.95 
  Clothes: 99.95 
  Book: 9.49 </p>
<p>Now that the XML data is available through Java (using various get methods), it is 
quite easy to extend UnmarshallPay.java to write it into an Office document. </p>
<p>clubs.xml as Java Code 
The JAXB manipulation of clubs.xml follows the same steps as used on pay.xml: </p>
<h2 id="1-convert-clubsxml-to-xsd-at-freeformattercom-using-the-salami-slice">1.  Convert clubs.xml to XSD at freeformatter.com using the "Salami Slice"</h2>
<p>mapping.  </p>
<h2 id="2-convert-companyxsd-into-java-classes-with-xjc">2.  Convert company.xsd into Java classes with xjc:</h2>
<p>xjc -p Clubs clubs.xsd </p>
<h2 id="3-compile-the-clubs-package">3.  Compile the Clubs package:</h2>
<p>javac Clubs/*.java<br />
Figure 19 shows the Clubs class diagrams. </p>
<p><img alt="" src="images/50-Importing_XML-19.png" /></p>
<p>Figure 19. The Clubs Class Diagrams. </p>
<p>The top-level class is ClubDatabase which maintains a list of Association objects. </p>
<p>Each Association object holds a list of Club objects. Club contains get/set methods for 
accessing its fields. My UnmarshallClubs.java example shows how to use these 
classes: </p>
<p>// in UnmarshallClubs.java 
import java.io.<em>; 
import java.util.</em>; 
import javax.xml.bind.<em>; 
import Clubs.</em>;  // the package for the Club classes </p>
<p>public class UnmarshallClubs<br />
{ 
  public static void main(String[] args)<br />
  { 
    try { 
      // initialize the Clubs objects using clubs.xml 
      JAXBContext jaxbContext =<br />
               JAXBContext.newInstance(ClubDatabase.class); 
      Unmarshaller jaxbUnmarshaller =<br />
               jaxbContext.createUnmarshaller(); 
      ClubDatabase cd = (ClubDatabase) jaxbUnmarshaller.unmarshal( 
                                 new File("clubs.xml")); </p>
<pre><code>  List&lt;Association&gt; assocList = cd.getAssociation();

  // print club names for all the associations 
  System.out.println("Associations"); 
  for(Association assoc : assocList) { 
    System.out.println("  " + assoc.getId()); 
    List&lt;Club&gt; clubs = assoc.getClub(); 
    for(Club club : clubs) 
      System.out.println("    " + club.getName()); 
  } 
}  
catch (JAXBException e) { 
  e.printStackTrace(); 
}
</code></pre>
<p>}  // end of main() </p>
<p>}  // end of UnmarshallClubs class </p>
<p>The unmarshalling is similar to before except that the ClubDatabase object is 
initialized with data from clubs.xml. The code iterates through the clubs in each 
association, printing their names: </p>
<p>Associations 
  BAWA 
    Castro Valley Wrestling Club 
    Coastside Grapplers 
    Dixon Ram Wrestling 
    East Bay Freestylers 
    Fairfield WrestlingClub 
    Godfather Wrestling Club 
    Golden Gate Wrestling Club 
    Mat Club USA 
    Pirate Wrestling Club 
    SF Elite Wrestling 
    Titan Wrestling Club 
  CAGWA 
    Big Bear Grizzlies Wrestling Club 
    California Grapplers Youth Wrestling 
     : 
     : 
    South Coast Wrestling Club 
    West Hills Hawks </p>
<p>Naming Conflicts 
The xjc tool works so well that a deep understanding of JAXB isn't usually needed. </p>
<p>The exception is when the XML contains a name conflict, which occurs if two or 
more attributes have the same name.  </p>
<p>There's a number of "value" name conflicts in weather.xml, which I've highlighted 
below: </p>
<?xml version="1.0" encoding="UTF-8"?>
<p><current> 
    <city id="1610780" name="Hat Yai"> 
        <coord lat="7.01" lon="100.48"/> 
        <country>TH</country> 
        <sun rise="2017-01-01T23:30:31" set="2017-01-02T11:14:18"/> 
    </city> 
    <temperature max="25" min="25" unit="metric" value="25"/> 
    <humidity unit="%" value="94"/> 
    <pressure unit="hPa" value="1011"/> 
    <wind> 
        <speed name="Gentle Breeze" value="3.6"/> 
        <gusts/> 
        <direction code="NNE" name="North-northeast" value="30"/> 
    </wind> 
    <clouds name="broken clouds" value="75"/> 
    <visibility value="5000"/> 
    <precipitation mode="no"/> 
    <weather icon="10n" number="501" value="moderate rain"/> 
    <lastupdate value="2017-01-02T15:30:00"/> 
</current> </p>
<p>The "value" attribute is used nine times in different contexts. This doesn't pose a 
problem for freeformatter.com, which quietly generates weather.xsd. The name 
conflict is only reported when xjc tries to generate Java classes: </p>
<blockquote>
<p>xjc -p Weather weather.xsd 
parsing a schema... </p>
</blockquote>
<p>[ERROR] Property "Value" is already defined.  </p>
<p>Use <jaxb:property> to resolve this conflict. </p>
<pre><code>:  // many more error messages 
</code></pre>
<p>As the error message advises, I need to add jaxb:property annotations to the XSD file 
to allow xjc to correctly translate the attributes. For example, the first offender in 
weather.xsd is: 
<xs:attribute type="xs:float" name="value"/> 
Its jaxb:property annotation is: </p>
<p><xs:attribute type="xs:float" name="value"> 
    <!-- avoid "value" name conflict --> 
    <xs:annotation> 
        <xs:appinfo> 
            <jaxb:property name="valueAttribute"/> 
        </xs:appinfo> 
    </xs:annotation> 
</xs:attribute> </p>
<p>This same change is applied to all the other conflicting attribute names. </p>
<p>In addition, the new "jaxb" label must be linked to its JAXB schema at the start of the 
XSD file: </p>
<!-- in the xs:schema element -->
<p>xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" 
jaxb:version="2.1" </p>
<p>If you want to understand what's happening in more detail, the best place to start is the 
tutorial at Oracle: https://docs.oracle.com/javase/tutorial/jaxb/intro/. </p>
<p>When xjc is passed this modified weather.xsd file, the Java classes are correctly 
generated. Figure 20 shows only the class names to reduce the diagram's size. </p>
<p><img alt="" src="images/50-Importing_XML-20.png" /></p>
<p>Figure 20. The Weather Class Diagrams. </p>
<p>The top-level class is Current which stores the weather attributes as objects. </p>
<p>My UnmarshallWeather.java example examines weather.xml to report if it was 
raining on the report day: </p>
<p>// in UnmarshallWeather.java 
public class UnmarshallWeather<br />
{ 
  public static void main(String[] args)<br />
  { 
    try { 
      JAXBContext jaxbContext =<br />
                    JAXBContext.newInstance(Current.class); 
      Unmarshaller jaxbUnmarshaller =<br />
                    jaxbContext.createUnmarshaller(); 
      Current currWeather = (Current) jaxbUnmarshaller.unmarshal(<br />
                                 new File("weather.xml")); </p>
<pre><code>  // get precipitation as a boolean 
  String rainingStatus =  
            currWeather.getPrecipitation().getValue(); 
  boolean isRaining = rainingStatus.equals("yes");

  // get date in day/month/year format 
  XMLGregorianCalendar gCal =  
           currWeather.getLastupdate().getValueAttribute(); 
  Calendar cal = gCal.toGregorianCalendar();

  SimpleDateFormat formatter =  
                      new SimpleDateFormat("dd/MM/yyyy"); 
  formatter.setTimeZone(cal.getTimeZone()); 
  String dateStr = formatter.format(cal.getTime());

  if (isRaining) 
    System.out.println("It was raining on " + dateStr); 
  else 
    System.out.println("It was NOT raining on " + dateStr); 
}  
catch (JAXBException e) { 
  e.printStackTrace(); 
}
</code></pre>
<p>}  // end of main() </p>
<p>}  // end of UnmarshallWeather class </p>
<p>The output is: 
It was NOT raining on 02/01/2017 </p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="50%20Part%209%20The%20ODF%20Format.html" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Part 9 The ODF Format
            </div>
          </div>
        </a>
      
      
        <a href="51-Simple_ODF.html" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Chapter 51. Simple ODF
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": ".", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "assets/javascripts/workers/search.fb4a9340.min.js", "version": null}</script>
    
    
      <script src="assets/javascripts/bundle.a1c7c35e.min.js"></script>
      
    
  </body>
</html>